# -*- coding: utf-8 -*-
"""chco_h1_atr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13yNlnwUA55o7iJ4wT21Xhd-KHdXHJQ_-
"""

from AlgorithmImports import *

class SleepyRedOrangeSalamander(QCAlgorithm):
    def initialize(self):
        self.set_start_date(1997, 1, 1)
        self.set_cash(10000)

        self.symbol = self.add_equity("CHCO", Resolution.HOUR, data_normalization_mode=DataNormalizationMode.Raw).symbol
        self.securities[self.symbol].set_fee_model(ConstantFeeModel(0))

        self.set_warm_up(timedelta(days=200))

        # Variables de control
        self.trade = False
        self.previous_low = None
        self.previous_high = None
        self.entry_price = None
        self.stop_price = None
        self.take_price = None
        self.entry_time = None  # Marca de tiempo completa
        self.total_days_invested = 0  # Acumulador de tiempo invertido en días

        # Indicadores
        self.atr = self.ATR(self.symbol, 2000, Resolution.HOUR)
        self.atr2 = self.ATR(self.symbol, 1, Resolution.HOUR)

        self.sma_daily = SimpleMovingAverage(200)
        consolidator = TradeBarConsolidator(timedelta(days=1))
        self.subscription_manager.add_consolidator(self.symbol, consolidator)
        consolidator.data_consolidated += lambda sender, bar: self.update_sma_daily(bar)

    def update_sma_daily(self, bar):
        self.sma_daily.update(bar.end_time, bar.close)

    def on_data(self, data: Slice):
        if self.IsWarmingUp:
            return

        trade_bar = data.Bars.get(self.symbol)
        if trade_bar is None:
            return

        high = trade_bar.High
        low = trade_bar.Low
        close = trade_bar.Close
        atr_value = self.atr.Current.Value
        atr_value2 = self.atr2.Current.Value

        # Si hay una operación abierta, verificar si se debe cerrar
        if self.trade:
            if close <= self.stop_price or close >= self.take_price:
                self.Liquidate(self.symbol)
                self.trade = False

                # Calcular tiempo invertido en días (incluyendo horas y minutos)
                exit_time = self.Time  # Fecha y hora de salida
                days_held = (exit_time - self.entry_time).total_seconds() / 86400  # Convertir segundos a días
                self.total_days_invested += days_held

                self.Debug(f"Posición cerrada. Duración: {days_held:.2f} días. Total acumulado: {self.total_days_invested:.2f} días")
                return

        # Condición de entrada: abrir nueva posición si los criterios se cumplen
        if self.previous_low is not None and not self.trade:
            if close > self.sma_daily.Current.Value and close < self.previous_low and atr_value2 > atr_value * 2:
                self.set_holdings(self.symbol, 1)
                self.trade = True

                self.entry_price = self.Portfolio[self.symbol].AveragePrice
                self.stop_price = self.entry_price - atr_value2 / 4
                self.take_price = self.entry_price + atr_value2 / 2
                self.entry_time = self.Time  # Guardar fecha y hora de entrada

                self.Debug(f"Operación abierta en {self.entry_price}. Stop: {self.stop_price}, Take: {self.take_price}")

        self.previous_low = low
        self.previous_high = high

    def on_end_of_algorithm(self):
        self.Debug(f"Tiempo total invertido en días: {self.total_days_invested:.2f}")